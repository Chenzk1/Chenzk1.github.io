---
title: ML-LightGBM
date: 2021-12-10
categories: 
    - Learning
tags:  
    - ML
---
[toc]
## 原理

### 动机

解决GBDT遇到海量数据时的问题：GBDT 在每一次迭代的时候，都需要遍历整个训练数据多次。如果把整个训练数据装进内存则会限制训练数据的大小；如果不装进内存，反复地读写训练数据又会消耗非常大的时间。

<!-- more -->

### 对xgboost的优化

- 基于 Histogram 的决策树算法
- 带深度限制的 Leaf-wise 的叶子生长策略
- 直方图做差加速
- 直接支持类别特征(Categorical Feature)
- Cache 命中率优化
- 基于直方图的稀疏特征优化
- 多线程优化

#### 基于 Histogram 的决策树算法

- 做法：把连续的浮点特征值离散化成k个整数，同时构造一个宽度为k的直方图。在遍历数据的时候，根据离散化后的值作为索引在直方图中累积统计量，当遍历一次数据后，直方图累积了需要的统计量，然后根据直方图的离散值，遍历寻找最优的分割点。
- 优点
  - 内存消耗小：不需要保存既保存数据的特征值，又保存预排序结果，只保存k个key-values即可
  - 时间消耗小：只需要计算k次增益
  - 泛化性能增强：决策树是弱模型，分割点精确与否不是很重要，更粗的分割点还可以引入噪音，增强泛化性能，防止过拟合

#### 带深度限制的 Leaf-wise 的叶子生长策略

- Level-wise 过一次数据可以**同时分裂同一层的叶子**，容易进行多线程优化，也好控制模型复杂度，不容易过拟合。但实际上 Level-wise 是一种低效的算法，因为它不加区分的对待同一层的叶子，带来了很多没必要的开销，因为实际上很多叶子的分裂增益较低，没必要进行搜索和分裂。
- Leaf-wise 则是一种更为高效的策略，每次从当前所有叶子中，找到**分裂增益最大的一个叶子**，然后分裂，如此循环。因此同 Level-wise 相比，在分裂次数相同的情况下，Leaf-wise 可以降低更多的误差，得到更好的精度。Leaf-wise 的缺点是可能会长出比较深的决策树，产生过拟合。因此 LightGBM 在 Leaf-wise 之上增加了一个最大深度的限制，在保证高效率的同时防止过拟合。

#### 直方图加速

- 一个叶子的直方图可以由它的父亲节点的直方图与它兄弟的直方图做差得到。通常构造直方图，需要遍历该叶子上的所有数据，但直方图做差仅需遍历直方图的k个桶。利用这个方法，LightGBM 可以在构造一个叶子的直方图后，可以用非常微小的代价得到它兄弟叶子的直方图。加速一倍。

#### 接受categorical features

LightGBM 可以直接使用 categorical features（分类特征）作为 input（输入）. 它不需要被转换成 one-hot coding（独热编码）, 并且它比 one-hot coding（独热编码）更快（约快上 8 倍）。

#### 并行学习

目前支持特征并行和数据并行的两种。

- 特征并行：主要思想是在不同机器在不同的特征集合上分别寻找最优的分割点，然后在机器间同步最优的分割点。
- 数据并行：让不同的机器先在本地构造直方图，然后进行全局的合并，最后在合并的直方图上面寻找最优分割点。

## 参数

    params = {  
        'boosting_type': 'gbdt',  
        'objective': 'binary',  
        'metric': {'binary_logloss', 'auc'},  #二进制对数损失
        'num_leaves': 5,  
        'max_depth': 6,  
        'min_data_in_leaf': 450,  
        'learning_rate': 0.1,  
        'feature_fraction': 0.9,  
        'bagging_fraction': 0.95,  
        'bagging_freq': 5,  
        'lambda_l1': 1,    
        'lambda_l2': 0.001,  # 越小l2正则程度越高  
        'min_gain_to_split': 0.2,  
        'verbose': 5,  
        'is_unbalance': True  
    }  